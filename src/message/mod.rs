//! Messages (often called _packets_ in other server implementations) that
//! Phantasy Star Online communicates with.
//!
//! There are 3 sets of messages across all of the games: the login server,
//! the patch server, and the ship server. Each have their own ID namespace.

pub mod staticvec;

/// A prelude for modules that use the `define_messages` macro.
mod prelude {
    pub use std::io;
    pub use std::io::{Read, Write};
    pub use std::marker::PhantomData;
    pub use std::net::Ipv4Addr;

    pub use byteorder::{LittleEndian, BigEndian, ReadBytesExt, WriteBytesExt};

    pub use psocrypto::{Encryptor, Decryptor};

    pub use typenum::uint::Unsigned;
    pub use typenum::NonZero;

    pub use super::MessageEncode;
    pub use super::MessageDecode;
    pub use super::Serial;
    pub use super::HdrSerial;
    pub use super::MsgHeader;
    pub use super::staticvec::StaticVec;
}

use self::prelude::*;

/// An encodable message. Implement for both the message enumeration and each individual message
/// body. For the message namespace enumeration, there should be a way of sending an 'ack' message
/// that does not contain the body of the message, rather only the header.
pub trait MessageEncode {
    /// Encode this message into a Write.
    fn encode_msg(&self, dst: &mut Write, encryptor: Option<&mut Encryptor>) -> io::Result<()>;
}

/// A decodable message. The implementation must be on a Sized because we return
/// Self by value. Should be implemented over an enum of possible messages.
pub trait MessageDecode: Sized {
    /// Decode the data in src into an instance of Self.
    fn decode_msg(src: &mut Read, decryptor: Option<&mut Decryptor>) -> io::Result<Self>;
}

/// A serializable type.
pub trait Serial: Sized {
    fn serialize(value: &Self, dst: &mut Write) -> io::Result<()>;
    fn deserialize(src: &mut Read) -> io::Result<Self>;
    fn serial_len(value: &Self) -> usize;

    fn serial_flags(_: &Self) -> u32 { 0 }
}

/// A generic message header. Only used in deserialization.
#[derive(Clone, Copy, Debug)]
pub struct MsgHeader {
    pub len: u32,
    pub msg_type: u32,
    pub flags: u32
}

impl MsgHeader {
    pub fn new(len: u32, msg_type: u32, flags: u32) -> MsgHeader {
        MsgHeader { len: len, msg_type: msg_type, flags: flags }
    }
}

/// A trait that serializes and deserializes message headers.
///
/// To use, define a type named `HdrSerializer` that is empty inside a message module, and implement
/// this trait over it. The `define_messages` macro refers to `HdrSerializer` internally, and you
/// will get compile errors unless it's available.
///
/// The packet header for each group of messages is similar but not the same in PSO.
/// Notably, the patch server does not have a `flags` field at all.
pub trait HdrSerial {
    /// Deserialize the header into a `MsgHeader`.
    ///
    /// The message size should have the header size subtracted, or the MessageDecode
    /// implementation will not be able to correctly buffer the message when decoding.
    fn hdr_deserialize(src: &mut Read, decryptor: Option<&mut Decryptor>) -> io::Result<MsgHeader>;

    /// Serialize the message header for a given message.
    ///
    /// The message size should include the header size. The incoming value is only the size of
    /// the (encrypted) message itself, so you need to add the header size yourself.
    fn hdr_serialize(value: &MsgHeader, dst: &mut Write, encryptor: Option<&mut Encryptor>) -> io::Result<()>;
}

macro_rules! define_messages {
    ($($id:expr => $name:ident { $($message:tt)* } ),*) => {

        $(msg_struct!{ $name { $($message)* } })*

        /// An enumeration of messages generated by the `define_messages` macro.
        #[derive(Debug)]
        pub enum Message {
            $(
                $name(Option<$name>),
            )*
        }

        $(impl MessageEncode for $name {
            fn encode_msg(&self, dst: &mut Write, encryptor: Option<&mut Encryptor>) -> io::Result<()> {
                use std::io::Cursor;

                let hdr = MsgHeader {
                    len: <$name as Serial>::serial_len(self) as u32,
                    msg_type: $id as u32,
                    flags: <$name as Serial>::serial_flags(self) as u32
                };

                let mut sbuf = vec![0u8; hdr.len as usize];
                let mut ebuf = vec![0u8; hdr.len as usize];
                if let Some(e) = encryptor {
                    try!(HdrSerializer::hdr_serialize(&hdr, dst, Some(e)));
                    {
                        let mut cursor = Cursor::new(&mut sbuf[..]);
                        try!(<$name as Serial>::serialize(self, &mut cursor as &mut Write));
                    }
                    {
                        if let Err(s) = e.encrypt(&sbuf[..], &mut ebuf[..]) {
                            return Err(io::Error::new(io::ErrorKind::Other, s))
                        }
                    }
                    dst.write_all(&ebuf[..])
                } else {
                    try!(HdrSerializer::hdr_serialize(&hdr, dst, None));
                    <$name as Serial>::serialize(self, dst)
                }
            }
        })*

        impl MessageEncode for Message {
            fn encode_msg(&self, dst: &mut Write, encrypter: Option<&mut Encryptor>) -> io::Result<()> {
                fn encode_hdr_only(msg_type: u32, dst: &mut Write, encryptor: Option<&mut Encryptor>) -> io::Result<()> {
                    let hdr = MsgHeader { len: 0, msg_type: msg_type, flags: 0 };
                    HdrSerializer::hdr_serialize(&hdr, dst, encryptor)
                }
                match self {
                    $(&Message::$name(Some(ref s)) => s.encode_msg(dst, encrypter),)*
                    $(&Message::$name(_) => encode_hdr_only($id, dst, encrypter),)*
                }
            }
        }

        impl MessageDecode for Message {
            fn decode_msg(src: &mut Read, decryptor: Option<&mut Decryptor>) -> io::Result<Self> {
                use std::borrow::BorrowMut;
                use std::io::Cursor;

                let hdr;
                let mut ebuf: Vec<u8>;

                if let Some(d) = decryptor {
                    hdr = try!(HdrSerializer::hdr_deserialize(src, Some(d)));
                    if hdr.len == 0 {
                        // The message is an "ack" type, meaning there's no actual body.
                        return match hdr.msg_type {
                            $($id => Ok(Message::$name(None)),)*
                            _ => return Err(io::Error::new(io::ErrorKind::InvalidInput, "Unrecognized message id (ack message, encrypted)"))
                        }
                    }

                    let mut sbuf = vec![0u8; hdr.len as usize];
                    ebuf = vec![0u8; hdr.len as usize];
                    {if try!(src.read(sbuf.borrow_mut())) != hdr.len as usize {
                        return Err(io::Error::new(io::ErrorKind::Other, "Buffer underflow decoding message (decrypting)"))
                    }}
                    if let Err(_) = d.decrypt(&sbuf[..], &mut ebuf[..]) {
                        return Err(io::Error::new(io::ErrorKind::Other, "Decryption of message failed"))
                    }
                } else {
                    hdr = try!(HdrSerializer::hdr_deserialize(src, None));
                    if hdr.len == 0 {
                        // The message is an "ack" type, meaning there's no actual body.
                        return match hdr.msg_type {
                            $($id => Ok(Message::$name(None)),)*
                            _ => return Err(io::Error::new(io::ErrorKind::InvalidInput, "Unrecognized message id (ack message, unencrypted)"))
                        }
                    }

                    ebuf = vec![0u8; hdr.len as usize];
                    if try!(src.read(ebuf.borrow_mut())) != hdr.len as usize {
                        return Err(io::Error::new(io::ErrorKind::Other, "Buffer underflow decoding message (not decrypting)"))
                    }
                }

                let mut cursor = Cursor::new(ebuf);
                match hdr.msg_type {
                    $($id => <$name as Serial>::deserialize(&mut cursor as &mut Read).map(|s| Message::$name(Some(s))),)*
                    _ => Err(io::Error::new(io::ErrorKind::InvalidInput, "Unrecognized message id"))
                }
            }
        }
    };
}

macro_rules! msg_struct {
    // some named fields
    ($name:ident { $($fname:ident: $fty:ty),+ }) => {
        #[derive(Default, Debug)]
        pub struct $name {
            $(pub $fname: $fty),*
        }
        impl Serial for $name {
            fn serial_len(value: &$name) -> usize {
                let mut size: usize = 0;
                $(size += <$fty as Serial>::serial_len(&value.$fname);)*
                size
            }
            fn serialize(value: &$name, dst: &mut Write) -> io::Result<()> {
                $(try!(<$fty as Serial>::serialize(&value.$fname, dst));)*
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<$name> {
                Ok( $name {
                    $($fname: try!(<$fty as Serial>::deserialize(src))),*
                })
            }
        }
    };
    // no fields
    // custom encoder/decoder
    ($name:ident { $($fname:ident: $fty:ty),+; $impl_struct:item }) => {
        #[derive(Debug)]
        pub struct $name {
            $(pub $fname: $fty),*
        }

        $impl_struct
    };
    ($name:ident {}) => {
        #[derive(Debug)]
        pub struct $name;

        impl Serial for $name {
            fn serial_len(_: &$name) -> usize { 0 }
            fn serialize(_: &$name, _: &mut Write) -> io::Result<()> { Ok(()) }
            fn deserialize(_: &mut Read) -> io::Result<$name> { Ok($name) }
        }
    };
}

macro_rules! impl_prim_serial {
    ($name:ident, 1, $enc_name:ident, $dec_name:ident) => {
        impl Serial for $name {
            fn serial_len(_: &$name) -> usize { 1 }
            fn serialize(value: &$name, dst: &mut Write) -> io::Result<()> {
                try!(dst.$enc_name(*value));
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<$name> {
                src.$dec_name().map_err(|err| io::Error::from(err))
            }
        }
    };
    ($name:ident, $len:expr, $enc_name:ident, $dec_name:ident) => {
        impl Serial for $name {
            fn serial_len(_: &$name) -> usize { $len }
            fn serialize(value: &$name, dst: &mut Write) -> io::Result<()> {
                try!(dst.$enc_name::<LittleEndian>(*value));
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<$name> {
                src.$dec_name::<LittleEndian>().map_err(|err| io::Error::from(err))
            }
        }
    }
}

// this macro sucks
macro_rules! impl_array_serial {
    ($t:ty, 1, $enc_name:ident, $dec_name:ident, $max_size:expr) => {
        impl Serial for [$t; $max_size] {
            fn serial_len(_: &Self) -> usize {
                use std::mem;
                mem::size_of::<Self>()
            }
            fn serialize(value: &Self, dst: &mut Write) -> io::Result<()> {
                for x in value.iter() {
                    try!(dst.$enc_name(*x));
                }
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<Self> {
                let mut buf: [$t; $max_size] = [<$t as Default>::default(); $max_size];
                for x in 0..$max_size {
                    buf[x] = try!(src.$dec_name());
                }
                Ok(buf)
            }
        }
    };
    ($t:ty, $size:expr, $enc_name:ident, $dec_name:ident, $max_size:expr) => {
        impl Serial for [$t; $max_size] {
            fn serial_len(_: &Self) -> usize {
                use std::mem;
                mem::size_of::<Self>()
            }
            fn serialize(value: &Self, dst: &mut Write) -> io::Result<()> {
                for x in value.iter() {
                    try!(dst.$enc_name::<LittleEndian>(*x));
                }
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<Self> {
                let mut buf: [$t; $max_size] = [<$t as Default>::default(); $max_size];
                for x in 0..$max_size {
                    buf[x] = try!(src.$dec_name::<LittleEndian>());
                }
                Ok(buf)
            }
        }
    }
}

macro_rules! test_size {
    ($t:ty, $tname:ident, $size:expr) => {
        #[test]
        fn $tname() {
            use ::message::Serial;
            assert_eq!(<$t as Serial>::serial_len(&<$t as Default>::default()), $size);
        }
    }
}

impl_prim_serial!(i8,  1, write_i8,  read_i8);
impl_prim_serial!(u8,  1, write_u8,  read_u8);
impl_prim_serial!(i16, 2, write_i16, read_i16);
impl_prim_serial!(u16, 2, write_u16, read_u16);
impl_prim_serial!(i32, 4, write_i32, read_i32);
impl_prim_serial!(u32, 4, write_u32, read_u32);
impl_prim_serial!(i64, 8, write_i64, read_i64);
impl_prim_serial!(u64, 8, write_u64, read_u64);
impl_prim_serial!(f32, 4, write_f32, read_f32);
impl_prim_serial!(f64, 8, write_f64, read_f64);

// for the various string and padding sizes
// impl_array_serial!(u8, 1, write_u8, read_u8, 12);
impl_array_serial!(u8, 1, write_u8, read_u8, 16);
// impl_array_serial!(u8, 1, write_u8, read_u8, 20);
// impl_array_serial!(u8, 1, write_u8, read_u8, 44);
// impl_array_serial!(u8, 1, write_u8, read_u8, 64);

impl Serial for bool {
    fn serial_len(_: &bool) -> usize { 1 }
    fn serialize(value: &bool, dst: &mut Write) -> io::Result<()> {
        try!(dst.write_u8(if *value {1} else {0}));
        Ok(())
    }
    fn deserialize(src: &mut Read) -> io::Result<bool> {
        let v = try!(src.read_u8());
        if v > 1 {
            Err(io::Error::new(io::ErrorKind::InvalidInput, &format!("Invalid bool value, expecting 0 or 1, got {}", v)[..]))
        } else {
            Ok(v == 1)
        }
    }
}

pub mod patch;
