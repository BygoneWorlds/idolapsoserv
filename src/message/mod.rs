//! Messages (often called _packets_ in other server implementations) that
//! Phantasy Star Online communicates with.
//!
//! There are 3 sets of messages across all of the games: the login server,
//! the patch server, and the ship server. Each have their own ID namespace.

/// A prelude for modules that use the `define_messages` macro.
mod prelude {
    pub use std::io;
    pub use std::io::{Read, Write};

    pub use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};

    pub use super::MessageEncode;
    pub use super::MessageDecode;
    pub use super::Serial;
}

use self::prelude::*;

/// An encodable message. Implement for the direct message struct, not the wrapper
/// enumeration.
pub trait MessageEncode {
    /// Encode this message into a Write.
    fn encode_msg(&self, dst: &mut Write) -> io::Result<()>;
}

/// A decodable message. The implementation must be on a Sized because we return
/// Self by value. Should be implemented over an enum of possible messages.
pub trait MessageDecode: Sized {
    /// Decode the data in src into an instance of Self.
    fn decode_msg(src: &mut Read) -> io::Result<Self>;
}

/// A serializable type.
pub trait Serial: Sized {
    fn serialize(value: &Self, dst: &mut Write) -> io::Result<()>;
    fn deserialize(src: &mut Read) -> io::Result<Self>;
    fn serial_len(value: &Self) -> usize;
}

macro_rules! define_messages {
    ($($id:expr => $name:ident { $($message:tt)* } )*) => {

        $(msg_struct!{ $name { $($message)* } })*

        /// An enumeration of messages generated by the `define_messages` macro.
        pub enum Message {
            $(
                $name($name),
            )*
        }

        $(impl MessageEncode for $name {
            fn encode_msg(&self, dst: &mut Write) -> io::Result<()> {
                try!(<u16 as Serial>::serialize(&$id, dst));
                <$name as Serial>::serialize(self, dst)
            }
        })*

        impl MessageDecode for Message {
            fn decode_msg(src: &mut Read) -> io::Result<Self> {
                match try!(<u16 as Serial>::deserialize(src)) {
                    $($id => <$name as Serial>::deserialize(src).map(Message::$name),)*
                    _ => Err(io::Error::new(io::ErrorKind::InvalidInput, "Unrecognized message id"))
                }
            }
        }
    };
}

macro_rules! msg_struct {
    // some named fields
    ($name:ident { $($fname:ident: $fty:ty),+ }) => {
        pub struct $name {
            $(pub $fname: $fty),*
        }
        impl Serial for $name {
            fn serial_len(_: &$name) -> usize {
                use std::mem;
                mem::size_of::<$name>()
            }
            fn serialize(value: &$name, dst: &mut Write) -> io::Result<()> {
                $(try!(<$fty as Serial>::serialize(&value.$fname, dst));)*
                Ok(())
            }
            fn deserialize(_: &mut Read) -> io::Result<$name> {
                unimplemented!()
            }
        }
    };
    // no fields
    // custom encoder/decoder
    ($name:ident { $($fname:ident: $fty:ty),+; $impl_struct:item }) => {
        pub struct $name {
            $(pub $fname: $fty),*
        }

        $impl_struct
    };
    ($name:ident {}) => {
        pub struct $name;

        impl Serial for $name {
            fn serial_len(_: &$name) -> usize { 0 }
            fn serialize(_: &$name, _: &mut Write) -> io::Result<()> { Ok(()) }
            fn deserialize(_: &mut Read) -> io::Result<$name> { Ok($name) }
        }
    };
}

macro_rules! impl_prim_serial {
    ($name:ident, 1, $enc_name:ident, $dec_name:ident) => {
        impl Serial for $name {
            fn serial_len(_: &$name) -> usize { 1 }
            fn serialize(value: &$name, dst: &mut Write) -> io::Result<()> {
                try!(dst.$enc_name(*value));
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<$name> {
                src.$dec_name().map_err(|err| io::Error::from(err))
            }
        }
    };
    ($name:ident, $len:expr, $enc_name:ident, $dec_name:ident) => {
        impl Serial for $name {
            fn serial_len(_: &$name) -> usize { $len }
            fn serialize(value: &$name, dst: &mut Write) -> io::Result<()> {
                try!(dst.$enc_name::<LittleEndian>(*value));
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<$name> {
                src.$dec_name::<LittleEndian>().map_err(|err| io::Error::from(err))
            }
        }
    }
}

// this macro sucks
macro_rules! impl_array_serial {
    ($t:ty, 1, $enc_name:ident, $dec_name:ident, $max_size:expr) => {
        impl Serial for [$t; $max_size] {
            fn serial_len(_: &Self) -> usize {
                use std::mem;
                mem::size_of::<Self>()
            }
            fn serialize(value: &Self, dst: &mut Write) -> io::Result<()> {
                for x in value.iter() {
                    try!(dst.$enc_name(*x));
                }
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<Self> {
                let mut buf: [$t; $max_size] = [<$t as Default>::default(); $max_size];
                for x in 0..$max_size {
                    buf[x] = try!(src.$dec_name());
                }
                Ok(buf)
            }
        }
    };
    ($t:ty, $size:expr, $enc_name:ident, $dec_name:ident, $max_size:expr) => {
        impl Serial for [$t; $max_size] {
            fn serial_len(_: &Self) -> usize {
                use std::mem;
                mem::size_of::<Self>()
            }
            fn serialize(value: &Self, dst: &mut Write) -> io::Result<()> {
                for x in value.iter() {
                    try!(dst.$enc_name::<LittleEndian>(*x));
                }
                Ok(())
            }
            fn deserialize(src: &mut Read) -> io::Result<Self> {
                let mut buf: [$t; $max_size] = [<$t as Default>::default(); $max_size];
                for x in 0..$max_size {
                    buf[x] = try!(src.$dec_name::<LittleEndian>());
                }
                Ok(buf)
            }
        }
    }
}

macro_rules! test_size {
    ($t:ty, $tname:ident, $size:expr) => {
        #[test]
        fn $tname() {
            use std::mem;
            assert_eq!(mem::size_of::<$t>(), $size);
        }
    }
}

impl_prim_serial!(i8,  1, write_i8,  read_i8);
impl_prim_serial!(u8,  1, write_u8,  read_u8);
impl_prim_serial!(i16, 2, write_i16, read_i16);
impl_prim_serial!(u16, 2, write_u16, read_u16);
impl_prim_serial!(i32, 4, write_i32, read_i32);
impl_prim_serial!(u32, 4, write_u32, read_u32);
impl_prim_serial!(i64, 8, write_i64, read_i64);
impl_prim_serial!(u64, 8, write_u64, read_u64);
impl_prim_serial!(f32, 4, write_f32, read_f32);
impl_prim_serial!(f64, 8, write_f64, read_f64);

// for the various string and padding sizes
impl_array_serial!(u8, 1, write_u8, read_u8, 12);
impl_array_serial!(u8, 1, write_u8, read_u8, 16);
impl_array_serial!(u8, 1, write_u8, read_u8, 20);
impl_array_serial!(u8, 1, write_u8, read_u8, 44);
impl_array_serial!(u8, 1, write_u8, read_u8, 64);

impl Serial for bool {
    fn serial_len(_: &bool) -> usize { 1 }
    fn serialize(value: &bool, dst: &mut Write) -> io::Result<()> {
        try!(dst.write_u8(if *value {1} else {0}));
        Ok(())
    }
    fn deserialize(src: &mut Read) -> io::Result<bool> {
        let v = try!(src.read_u8());
        if v > 1 {
            Err(io::Error::new(io::ErrorKind::InvalidInput, &format!("Invalid bool value, expecting 0 or 1, got {}", v)[..]))
        } else {
            Ok(v == 1)
        }
    }
}

pub mod patch {
    use ::message::prelude::*;

    define_messages! {
        0x02 => Welcome {copyright: [u8; 44], padding: [u8; 20], server_vector: u32, client_vector: u32}
        0x04 => Login {padding1: [u8; 12], username: [u8; 16], password: [u8; 16], padding2: [u8; 64]}
        0x06 => FileSend {}
        0x07 => DataSend {}
        0x08 => FileDone {}
        0x09 => SetDirectory {}
        0x0A => OneDirUp {}
        0x0B => StartList {}
        0x0C => FileInfo {}
        0x0D => InfoFinished {}
        0x0F => FileInfoReply {}
        0x10 => FileListDone {}
        0x11 => SendInfo {}
        0x12 => SendDone {}
        0x13 => Motd {}
        0x14 => Redirect {}
        0x614 => Redirect6 {}
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        test_size!(Welcome, size_welcome, 0x4c);
        test_size!(Redirect, size_redirect, 0xc);
        test_size!(Redirect6, size_redirect6, 0x18);
        test_size!(FileSend, size_filesend, 0x3c);
        test_size!(DataSend, size_datasend, 0x10);
        test_size!(FileDone, size_filedone, 0x8);
        test_size!(SetDirectory, size_setdir, 0x44);
        test_size!(FileInfo, size_fileinfo, 0x28);
        test_size!(FileInfoReply, size_fileinforeply, 0x10);
        test_size!(SendInfo, size_sendinfo, 0xc);
    }
}

pub mod login {

}

pub mod ship {

}
